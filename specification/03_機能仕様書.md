# 機能仕様書

## 1. データ永続化

### 使用技術
- Jetpack DataStore (Preferences DataStore)

### 保存するデータ

#### 1.1 漢字別学習記録
各漢字（80字）ごとに正解回数と間違い回数を記録

```kotlin
// キー設計
// kanji_stats_{id}_correct: Int  // 正解回数
// kanji_stats_{id}_wrong: Int    // 間違い回数

data class KanjiStats(
    val kanjiId: Int,
    val correctCount: Int = 0,
    val wrongCount: Int = 0
)
```

#### 1.2 全体統計
```kotlin
// キー設計
// total_questions: Int  // 累計問題数
// total_correct: Int    // 累計正解数

data class TotalStats(
    val totalQuestions: Int = 0,
    val totalCorrect: Int = 0
) {
    val accuracyPercent: Int
        get() = if (totalQuestions > 0) {
            (totalCorrect * 100 / totalQuestions)
        } else 0
}
```

#### 1.3 設定値
```kotlin
// キー設計
// question_count: String  // "10", "20", "all"

enum class QuestionCount(val value: String, val displayName: String) {
    TEN("10", "10もん"),
    TWENTY("20", "20もん"),
    ALL("all", "ぜんぶ")
}
```

### DataStore実装例

```kotlin
class QuizDataStore(private val context: Context) {
    
    private val Context.dataStore by preferencesDataStore(name = "quiz_data")
    
    // 漢字別統計の保存
    suspend fun saveKanjiStats(kanjiId: Int, correct: Int, wrong: Int) {
        context.dataStore.edit { prefs ->
            prefs[intPreferencesKey("kanji_${kanjiId}_correct")] = correct
            prefs[intPreferencesKey("kanji_${kanjiId}_wrong")] = wrong
        }
    }
    
    // 漢字別統計の取得
    fun getKanjiStats(kanjiId: Int): Flow<KanjiStats> {
        return context.dataStore.data.map { prefs ->
            KanjiStats(
                kanjiId = kanjiId,
                correctCount = prefs[intPreferencesKey("kanji_${kanjiId}_correct")] ?: 0,
                wrongCount = prefs[intPreferencesKey("kanji_${kanjiId}_wrong")] ?: 0
            )
        }
    }
    
    // 全漢字の統計を取得
    suspend fun getAllKanjiStats(): Map<Int, KanjiStats> {
        return context.dataStore.data.first().let { prefs ->
            (1..80).associate { id ->
                id to KanjiStats(
                    kanjiId = id,
                    correctCount = prefs[intPreferencesKey("kanji_${id}_correct")] ?: 0,
                    wrongCount = prefs[intPreferencesKey("kanji_${id}_wrong")] ?: 0
                )
            }
        }
    }
    
    // 全体統計の保存
    suspend fun saveTotalStats(total: Int, correct: Int) {
        context.dataStore.edit { prefs ->
            prefs[intPreferencesKey("total_questions")] = total
            prefs[intPreferencesKey("total_correct")] = correct
        }
    }
    
    // 全体統計の取得
    fun getTotalStats(): Flow<TotalStats> {
        return context.dataStore.data.map { prefs ->
            TotalStats(
                totalQuestions = prefs[intPreferencesKey("total_questions")] ?: 0,
                totalCorrect = prefs[intPreferencesKey("total_correct")] ?: 0
            )
        }
    }
    
    // 設定の保存
    suspend fun saveQuestionCount(count: QuestionCount) {
        context.dataStore.edit { prefs ->
            prefs[stringPreferencesKey("question_count")] = count.value
        }
    }
    
    // 設定の取得
    fun getQuestionCount(): Flow<QuestionCount> {
        return context.dataStore.data.map { prefs ->
            when (prefs[stringPreferencesKey("question_count")]) {
                "20" -> QuestionCount.TWENTY
                "all" -> QuestionCount.ALL
                else -> QuestionCount.TEN
            }
        }
    }
    
    // 全データリセット
    suspend fun resetAllData() {
        context.dataStore.edit { it.clear() }
    }
}
```

## 2. クイズロジック

### 2.1 クイズモード

```kotlin
enum class QuizMode {
    NORMAL,  // 通常モード: 全80字からランダム
    WEAK     // 苦手モード: 苦手な漢字のみ
}
```

### 2.2 苦手漢字の判定

```kotlin
fun isWeakKanji(stats: KanjiStats): Boolean {
    return stats.wrongCount > stats.correctCount
}

fun getWeakKanjiList(allStats: Map<Int, KanjiStats>): List<KanjiItem> {
    return allStats
        .filter { (_, stats) -> isWeakKanji(stats) }
        .mapNotNull { (id, _) -> KanjiData.getById(id) }
        .sortedByDescending { kanji ->
            val stats = allStats[kanji.id]!!
            stats.wrongCount - stats.correctCount  // 苦手度が高い順
        }
}
```

### 2.3 クイズ問題生成

```kotlin
fun generateQuizQuestions(
    mode: QuizMode,
    count: QuestionCount,
    allStats: Map<Int, KanjiStats>
): List<KanjiItem> {
    val sourceList = when (mode) {
        QuizMode.NORMAL -> KanjiData.allKanji.shuffled()
        QuizMode.WEAK -> getWeakKanjiList(allStats).shuffled()
    }
    
    val questionCount = when (count) {
        QuestionCount.TEN -> 10
        QuestionCount.TWENTY -> 20
        QuestionCount.ALL -> sourceList.size
    }
    
    return sourceList.take(minOf(questionCount, sourceList.size))
}
```

### 2.4 回答処理

```kotlin
data class AnswerResult(
    val isCorrect: Boolean,
    val correctReading: String,
    val selectedReading: String
)

fun processAnswer(
    currentKanji: KanjiItem,
    selectedReading: String,
    currentStats: KanjiStats
): Pair<AnswerResult, KanjiStats> {
    val isCorrect = selectedReading == currentKanji.reading
    
    val newStats = if (isCorrect) {
        currentStats.copy(correctCount = currentStats.correctCount + 1)
    } else {
        currentStats.copy(wrongCount = currentStats.wrongCount + 1)
    }
    
    val result = AnswerResult(
        isCorrect = isCorrect,
        correctReading = currentKanji.reading,
        selectedReading = selectedReading
    )
    
    return result to newStats
}
```

## 3. 画面遷移

### ナビゲーション構造

```
StartScreen
    ├── SettingsScreen
    │       └── ReportScreen
    └── QuizScreen
            └── ResultScreen
                    ├── (もういっかい) → QuizScreen
                    └── (スタートにもどる) → StartScreen
```

### Navigation実装例

```kotlin
sealed class Screen(val route: String) {
    object Start : Screen("start")
    object Settings : Screen("settings")
    object Report : Screen("report")
    object Quiz : Screen("quiz/{mode}") {
        fun createRoute(mode: QuizMode) = "quiz/${mode.name}"
    }
    object Result : Screen("result")
}

@Composable
fun AppNavigation() {
    val navController = rememberNavController()
    
    NavHost(navController, startDestination = Screen.Start.route) {
        composable(Screen.Start.route) {
            StartScreen(
                onStartQuiz = { mode ->
                    navController.navigate(Screen.Quiz.createRoute(mode))
                },
                onOpenSettings = {
                    navController.navigate(Screen.Settings.route)
                }
            )
        }
        
        composable(Screen.Settings.route) {
            SettingsScreen(
                onBack = { navController.popBackStack() },
                onOpenReport = {
                    navController.navigate(Screen.Report.route)
                }
            )
        }
        
        composable(Screen.Report.route) {
            ReportScreen(
                onBack = { navController.popBackStack() }
            )
        }
        
        composable(
            route = Screen.Quiz.route,
            arguments = listOf(navArgument("mode") { type = NavType.StringType })
        ) { backStackEntry ->
            val mode = QuizMode.valueOf(
                backStackEntry.arguments?.getString("mode") ?: "NORMAL"
            )
            QuizScreen(
                mode = mode,
                onFinish = { score, total, wrongList ->
                    // ResultScreenへ遷移（結果データを渡す）
                    navController.navigate(Screen.Result.route)
                },
                onExit = {
                    navController.navigate(Screen.Start.route) {
                        popUpTo(Screen.Start.route) { inclusive = true }
                    }
                }
            )
        }
        
        composable(Screen.Result.route) {
            ResultScreen(
                onRetry = { mode ->
                    navController.navigate(Screen.Quiz.createRoute(mode)) {
                        popUpTo(Screen.Start.route)
                    }
                },
                onBackToStart = {
                    navController.navigate(Screen.Start.route) {
                        popUpTo(Screen.Start.route) { inclusive = true }
                    }
                }
            )
        }
    }
}
```

## 4. ViewModel設計

### QuizViewModel

```kotlin
@HiltViewModel
class QuizViewModel @Inject constructor(
    private val dataStore: QuizDataStore
) : ViewModel() {
    
    // UI状態
    private val _uiState = MutableStateFlow(QuizUiState())
    val uiState: StateFlow<QuizUiState> = _uiState.asStateFlow()
    
    // クイズ開始
    fun startQuiz(mode: QuizMode) {
        viewModelScope.launch {
            val allStats = dataStore.getAllKanjiStats()
            val questionCount = dataStore.getQuestionCount().first()
            val questions = generateQuizQuestions(mode, questionCount, allStats)
            
            if (questions.isEmpty() && mode == QuizMode.WEAK) {
                // 苦手漢字がない場合のエラーハンドリング
                return@launch
            }
            
            _uiState.update {
                it.copy(
                    mode = mode,
                    questions = questions,
                    currentIndex = 0,
                    score = 0,
                    choices = generateChoices(questions.first()),
                    isAnswered = false,
                    showHint = false,
                    sessionWrongList = emptyList()
                )
            }
        }
    }
    
    // 回答選択
    fun selectAnswer(reading: String) {
        val state = _uiState.value
        if (state.isAnswered) return
        
        val currentKanji = state.questions[state.currentIndex]
        val isCorrect = reading == currentKanji.reading
        
        viewModelScope.launch {
            // 統計更新
            val currentStats = dataStore.getAllKanjiStats()[currentKanji.id] 
                ?: KanjiStats(currentKanji.id)
            
            val newStats = if (isCorrect) {
                currentStats.copy(correctCount = currentStats.correctCount + 1)
            } else {
                currentStats.copy(wrongCount = currentStats.wrongCount + 1)
            }
            dataStore.saveKanjiStats(currentKanji.id, newStats.correctCount, newStats.wrongCount)
            
            // 全体統計更新
            val totalStats = dataStore.getTotalStats().first()
            dataStore.saveTotalStats(
                total = totalStats.totalQuestions + 1,
                correct = totalStats.totalCorrect + if (isCorrect) 1 else 0
            )
            
            // UI更新
            _uiState.update {
                it.copy(
                    isAnswered = true,
                    isCorrect = isCorrect,
                    selectedReading = reading,
                    score = if (isCorrect) it.score + 1 else it.score,
                    sessionWrongList = if (!isCorrect) {
                        it.sessionWrongList + currentKanji
                    } else it.sessionWrongList
                )
            }
        }
    }
    
    // 次の問題へ
    fun nextQuestion() {
        val state = _uiState.value
        val nextIndex = state.currentIndex + 1
        
        if (nextIndex >= state.questions.size) {
            _uiState.update { it.copy(isFinished = true) }
        } else {
            val nextKanji = state.questions[nextIndex]
            _uiState.update {
                it.copy(
                    currentIndex = nextIndex,
                    choices = generateChoices(nextKanji),
                    isAnswered = false,
                    showHint = false,
                    isCorrect = null,
                    selectedReading = null
                )
            }
        }
    }
    
    // ヒント表示
    fun showHint() {
        _uiState.update { it.copy(showHint = true) }
    }
}

data class QuizUiState(
    val mode: QuizMode = QuizMode.NORMAL,
    val questions: List<KanjiItem> = emptyList(),
    val currentIndex: Int = 0,
    val score: Int = 0,
    val choices: List<String> = emptyList(),
    val isAnswered: Boolean = false,
    val isCorrect: Boolean? = null,
    val selectedReading: String? = null,
    val showHint: Boolean = false,
    val isFinished: Boolean = false,
    val sessionWrongList: List<KanjiItem> = emptyList()
) {
    val currentKanji: KanjiItem?
        get() = questions.getOrNull(currentIndex)
    
    val progress: Float
        get() = if (questions.isEmpty()) 0f else currentIndex.toFloat() / questions.size
}
```
